# 单位属性
战斗关卡中，每一个单位都使用相同的单位类`UnitAttributes`，包含了常用的固定属性和由其他[效果](#单位属性)等添加的额外元数据。

- 角色名
- 生命
- 攻击力
- 速度
- ......

一般来说，我们会为属性安排一个单一的数值，例如：

- 角色名：豆糕（字符串）
- 生命：100（整数）
- 攻击力：10（整数）
- 速度：114.5（浮点）
- ......

但这样显然有些不够。倘若其它操作都是直接对数值进行更改，那就会使得原始数值丢失。比如：

> 生命值＋20  
> 生命值*120%

这两个`效果`的添加顺序和移除顺序都会影响最终数值，这很显然不是我们想要的。我们想要**效果的施加顺序不影响最终数值**，且**更改移除前后数值应一致**。

一种解法是在需要时再**动态统计**属性的最终值。比如维护一个`效果列表`，获取属性时遍历该表，就能计算最终值。

但在本项目中，我们使用另一种解法：将这些数值属性解释为[Inst](#类：Inst)的集合。

## 类：Inst

成员名|类型|解释
---|---|---
id |string|标识名称。由不同Effect施加的Inst具有不同的id，可以通过此id避免重复添加inst
at |array[string]|生效位置，可以看作分类，用作指定类别数据的统计
const|bool|是否为“常量”。如果为否，计算时会把value视为指令，返回该指令的结果。
value |variant|值，任意变量。

## Inst有啥用？

随着Inst的横空出世，我们的`攻击力`属性现在看起来是这样的：

id|at|const|value
---|---|---|---
`base`|`default`|true|`50`
`buff_a`|`*`|true|`0.2`
`buff_b`|`+`|false|`-ifelse`, `<`, `50`, `-count`, `-get`, `defense`, `self`, `20`, `0` 

整个表是一个数组，每一行是一个Inst。