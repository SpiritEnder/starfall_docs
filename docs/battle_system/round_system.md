# 回合系统
回合系统由多个部分组成。

- [回合系统](#回合系统)
	- [单位行动顺序](#单位行动顺序)
		- [什么是跑圈？](#什么是跑圈)
		- [实现](#实现)
		- [改变速度会如何？](#改变速度会如何)
		- [预览队列](#预览队列)
	- [回合前后](#回合前后)

## 单位行动顺序
对一个回合制游戏来说，如何处理各个单位之间的行动顺序十分关键。本项目参考了类似《崩坏：星穹铁道》的速度系统。

### 什么是跑圈？
假设有一个长为1000米的环形跑道。它的起点与终点相同。所有的单位`unit`在回合开始时都站在起点上。每个单位都有自己的初始速度`speed`（单位均为米每秒）。  
要计算**下一个谁行动**，就是计算**谁先跑到终点**。  
那么，我们就需要获得剩余抵达时间`remain`，单位为秒。即，剩余距离除以速度，例如：

|单位|速度|剩余抵达时间|
|---|---:|---:|
|小洛|100|10|
|捷克|125|8|
|豆糕|80|12.5|

剩余时间最短的人**捷克**先抵达终点。随后抵达的是**小洛**，最后是**豆糕**。  
燃鹅我们的问题并没有结束。每一个人抵达终点后，会继续开始下一圈的路程。让我们考虑**小洛**抵达终点时的情况，计算经过的时间`time`，每人走出的距离`distance`。  
*由于**捷克**已经越过终点，其走出距离将重新计算。*

|单位|速度|经过的时间|走出的距离|剩余抵达时间|
|---|---:|---:|---:|---:|
|小洛|100   |10 |1000       |0  |
|捷克|125   |10 |250 (1250) |6  |
|豆糕|80    |10 |800        |2.5|

注意到，我们可以将两个时间进行合并。因为**当前经过的时间**与**剩余抵达时间**的加和总是每个人跑一圈的**周期**`cycle`的整数倍。

速度不变时，周期不变。因此我们暂且将当前的状态整合为以下几个参数：

|单位|周期|剩余抵达时间|
|---|---:|---:|
|小洛|10|0 (10)|
|捷克|8|6  |
|豆糕|12.5|2.5|

这样，每个人行动之后，将**剩余抵达时间**重置为**周期**，然后通过比较，找到剩余抵达时间最短的单位。

```
小洛：10，捷克，6，豆糕：2.5  
> 最短剩余用时：2.5
```
即小洛的回合结束后，豆糕将成为**行动者**。系统执行以下操作：
- 减少其余单位的剩余抵达时间，减少量为**行动者**（豆糕）的剩余行动时间。
- 重置**行动者**的剩余抵达时间为其周期。
```
小洛：10，捷克，6，豆糕：2.5  
> 最短剩余用时：2.5
> 时间经过2.5
小洛：7.5，捷克，3.5，豆糕：0  
> 豆糕行动
> 豆糕行动完毕，重置时间为周期
小洛：7.5，捷克，3.5，豆糕：12.5  
> 最短剩余用时：3.5
......
```
如此往复。

### 实现
```python
func m_next(attrs:Array) -> AttrStruct:
	# 剩余跑圈时长最小的，提取时间
	var min:int = 999
	for i in attrs:
		print(i.unit.chara_name," 剩余时间：",i.remain)
		if i.remain < min:
			min = i.remain
	# 全体减去最小值，如果减小到恰好为0则加入待行动列表
	var prepare:Array
	for i in attrs:
		i.remain -= min
		if i.remain == 0:
			print("[ ",i.unit.chara_name," ]")
			prepare.append(i)
	# 挑选出唯一行动对象
	var target = prepare.pick_random()
	for i in prepare:
		if i != target: # 对其他值进行检查
			if i.speed > target.speed: # 高速先行动
				target = i
			elif i.unit.team == -1 and target.unit.team == 1: # 友方先行动
				target = i
			elif i.unit.place < target.unit.place: # 靠前先行动
				target = i
			# 其他则随意
	target.remain = target.cycle # 将剩余时间（剩余距离）重置为周期
	return target
```
### 改变速度会如何？

速度的更改是不可避免的。所以，事实上每一次计算行动队列之前，要检查速度是否有变，如果有变，则刷新周期和剩余到达时间。

速度突变时，**剩余抵达距离**是不变的。因此有：  
剩余抵达距离 = 旧速度 * 旧剩余抵达时间 = 新速度 * 新剩余抵达时间，即：  
``remain *= new_speed / old_speed``
然后再计算周期和更新速度即可。

### 预览队列

在《崩坏：星穹铁道》中，你可以预览到接下来的行动队列，直到所有单位的下一次行动都出现一次。这实现起来不难，只要将当前状态向下多次推演即可。  
燃鹅每次速度更改都会造成原来的推演失效。所以，不能直接推演当前状态，而是要增加一个预览队列。

以上述例子，假如小洛行动时，速度被更改为了200，则预览队列会发生这样的变化：

|回合数|单位|行动次数|-->|单位|行动次数|
|:---:|---|---:|---|---|---:|
|1|小洛|1||小洛|1|
|2|豆糕|1||豆糕|1|
|3|捷克|1||小洛|2|
|4|小洛|2||捷克|2|
|5|捷克|2||小洛|3|
|6|豆糕|2||小洛|4|

小洛的回合增多。通过对比两个表，动画组件就能将小洛的第二次行动的图标前移，而捷克和豆糕第二次行动的图标会被推到小洛三四次行动的图标之后。

## 回合前后
